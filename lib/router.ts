import { IHandler } from "./bao";
import Context from "./context";
import Middleware from "./middleware";
import BaoRouter from "./router/router";

export default class Router {
  #router = new BaoRouter();

  /**
   * The middleware used by this router
   */
  middleware = new Middleware();

  /**
   * Register a route with the router
   *
   * @param method The HTTP method
   * @param path The path of the route
   * @param handler The path handler function
   */
  register(method: TMethods, path: string, handler: IHandler): void {
    if (method == "ANY") {
      this.#router.any(path, handler);
    } else {
      this.#router.on(method, path, handler);
    }
  }

  /**
   * Handles an incoming request
   *
   * @param ctx The Context object created by the request
   * @returns The Response generated by the path handler and middleware
   */
  async handle(ctx: Context): Promise<Response> {
    let method = ctx.method;
    if (method == "HEAD") {
      method = "GET";
    }

    const route = this.#router.find(method, ctx.path);

    // If route not found, send an empty 404
    if (route.handler == null) return new Response(null, { status: 404 });

    // Assign the route parameters
    ctx.params = route.params;

    // Run the Context through the middleware and route
    ctx = await this.middleware.before(ctx);
    if (!ctx.isLocked()) ctx = await Promise.resolve(route.handler(ctx));
    if (!ctx.isLocked()) ctx = await this.middleware.after(ctx);

    // Handle a HEAD request
    if (ctx.method == "HEAD") {
      ctx.res = new Response("", {
        status: (ctx.res as Response).status,
        statusText: (ctx.res as Response).statusText,
        headers: (ctx.res as Response).headers,
      });
    }

    return ctx.res;
  }
}

export type TMethods =
  | "ANY"
  | "GET"
  | "HEAD"
  | "POST"
  | "PUT"
  | "DELETE"
  | "CONNECT"
  | "OPTIONS"
  | "TRACE"
  | "PATCH";
